---
title: "day6-wrangling-tidyverse"
output: html_document
date: '2022-08-15'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

```{r}


library(tidyverse)
library(tidyr)
library(dplyr)
library(here)
library(janitor)
library(starwars)

```

## Read in the WB data files

```{r}

wb_indicators <- read_csv(here::here("data", "wb_indicators.csv"), na = c("..", ""))
wb_metadata <- read_csv(here::here("data", "wb_indicators_metadata.csv"))

```

## Tidy up my data

### Using pivot_longer to get years into a single column

```{r}

wb_indicators_long <- wb_indicators %>% 
  pivot_longer(cols = '2001 [YR2001]':'2020 [YR2020]',
               names_to = "year",
               values_to = "indicator_value")
```

### seperate to clean up the year column

```{r}


wb_clean <- wb_indicators_long %>%
  separate(col = year, into = c("year", "year_chr"), sep = " ") %>% # Separates
  select(-year_chr, -"Country Code", -"Series Code") %>% # Also exclude Country Code and Series Code
  mutate(year = as.numeric(year)) %>% # Makes the year column into numeric
  drop_na('Series Name') %>% # Drops all (entire) rows that have NA values
  pivot_wider(names_from = 'Series Name',
              values_from = indicator_value)

names(wb_clean) <- c("country", "year", "access_clean_fuels_pp", "access_electricity_pp", "co2_emmisions_kt", "fossil_fuel_consumption_pct", "water_stress")


# Widen the variables currently trapped in 'Series Name' to be spread across multiple columns, and put the values that populated the columns from 'indicator_value'

wb_subset <- wb_clean %>%
  filter(country %in% c("Algeria", "Barbados", "Argentina", "France", "Chile"))

```

## Plotting a graph

```{r}

# ggplot(data = wb_subset, aes(x = year, co2_emmisions_kt, group = country)) +
# geom_line()

# SAME THING

ggplot(data = wb_subset, aes(x = year, co2_emmisions_kt)) +
  geom_line(aes(color = country)) +
  facet_wrap(~country, ncol = 5)


```

## Filtering by rows

Example 1: Filter to only keep exact matches

```{r}
ex_1 <- starwars %>% 
  filter(mass > 180)
# Check code with min(ex_1$height)
```

```{r}
ex_2 <- starwars %>% 
  filter(eye_color == "blue")
# Check code with unique(ex_2$eye_color)
```

# Subset that only contains homeworld = Naboo

```{r}
ex_3 <- starwars %>% 
  filter(homeworld == "Naboo")
```

# Filter for 2 things to be true

```{r}
ex_4 <- starwars %>% 
  filter(height > 180 & homeworld == "Tatooine")
```

# Subset where hair color is brown & species is human

```{r}
ex_5 <- starwars %>%
  filter(hair_color == "brown" & species == "Human")
```

### Filtering OR statements

```{r}
ex_6 <- starwars %>% 
  filter(height > 180 | eye_color == "yellow")

ex_61 <- starwars %>%
  filter(homeworld == "NA")
```

# Subset that keeps rows if homeworld is Endor OR species is droid

```{r}
ex_7 <- starwars %>% 
  filter(homeworld == "Endor" | species == "Droid")

ex_71 <- starwars %>% 
  filter(homeworld == "Endor")
```

# Keep observations where eye color are blue, brown red

```{r}
ex_8 <- starwars %>%
  filter(eye_color == "blue" | eye_color == "brown" | eye_color == "red")

# OR

ex_9 <- starwars %>% 
  filter(eye_color %in% c("blue", "brown", "red"))
# goes through by row and asks does this value equal blue, brown or red?


## THIS IS NEVER WHAT YOU WANT TO DO
ex_10 <- starwars %>%
  filter(eye_color == c("blue", "brown", "red"))
# would go through and ask does eye_color value match blue, then goes to next row and asks does eye_color match brown, then goes to 3rd row and asks does eye_color match red, 4th row blue

```






